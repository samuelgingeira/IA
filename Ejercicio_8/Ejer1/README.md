1. Justificación de arquitectura (useReducer vs useState):
useReducer centraliza la lógica del carrito en un único lugar: acciones (ADD/INCREMENT/DECREMENT/REMOVE) y las reglas de actualización. Si usas múltiples useState —por ejemplo items y total— corres el riesgo de inconsistencias: al incrementar una cantidad necesitas actualizar items y luego recomputar y setear total, lo que crea dependencias entre estados y ventanas de inconsistencia donde items y total no coinciden (problema de sincronización). Además la lógica para incrementar/decrementar se duplicaría y sería más difícil testear. useReducer hace las transiciones atómicas y predecibles.

2. Análisis de rendimiento (BotonPromocion re-renderiza):
Primera hipótesis: alguna prop que recibe BotonPromocion está siendo recreada en cada render del padre (p. ej. una función inline o un objeto nuevo) y por tanto React la considera distinta. Con React DevTools: inspeccionaría el árbol y el profiler. En DevTools -> Components puedo seleccionar BotonPromocion y activar "Highlight updates". Luego en el Profiler hago una interacción (añadir producto) y veo qué componentes se actualizan y por qué (props que cambian). Si la causa es una función, la solución: memoizar la función con useCallback en el padre o mover BotonPromocion fuera del árbol que cambia; si son objetos/arrays, usar useMemo/useCallback o pasar solo los datos necesarios.